"""
#1,序列,内容连续,有序,可以下标索引的容器
#元组,列表,字符串都是序列
#切片就是从里面取出一部分组成一个新序列
序列[起始下标:结束下标:步长]     步长为1时候可以省略不写 切到结束下标-1
配套使用:序列.index()找对应下标
但是只会得到一个新序列

len统计元素个数
max统计容器最大元素(数值最大,字母靠后)
min统计容器最小元素

容器改列表 list(原容器)#(字典转列表时候value就没了)
容器改元组 tuple(原容器)#(字典转列表时候value就没了)
容器转字符串  str(原容器)#(字典转列表value保留)
容器转集合 set(原容器)#(字典转列表时候value就没了,数据无序且去重)

通用排序
sorted(容器名,[reverse=Ture])

字符串的代表其实是其背后代表他们的ASCII码位的对比
'abd'>'abc'

"""
#切片:
x1=[0,1,2,3,4,5,6,7,8,9,0]
print(f"x1是:{x1}")
x2=x1[0:6]
print(f"修改后为{x2}")

#步长-1会是什么
x3=x1[::-1]
print(f"切片后是:{x3}")
#########它会反转
print()


###############排序且反转
print(f"排序:{sorted(x1,reverse=True)}")

"""
集合不支持元素的重复,集合使用{}
不支持下标索引访问
但是允许修改
"""
print()
a1={2,5,6,7,8,9,'清融'}

print(f"a1的内容:{a1},它是类型是:{type(a1)}")  #类型为set



#添加新元素   集合.add()
a1.add('无畏')
print(a1)


#######移除元素
#集合.remove()
a1.remove('清融')
print(f"移除'清融'后的a1{a1}")
#随机移除一个                     pop()
kk=a1.pop()
print(f"随机移除后的a1:{a1},取出的是:{kk}")
#但是这个,字符串是随机的,数字的话优先考虑的是最前面最小那个
print()

a2={2,3,5,1,'久酷'}

##########消除集合1里集合2有的元素
a4=a1.difference_update(a2)
print(f"消除a2里有的数后的a1:{a1},然后a2是:{a2},a4是:{a4}")
#这个方法是彻底的消除,并不是取出
print()
############取两个集合的差集,集合1有而集合2没有的
a3=a1.difference(a2)
print(f"a1与a2他们的差集是a3:{a3}")

print()
#######两个集合的合并集合.union(集合2)
a5=a1.union(a2,a3)
print(f"a1与a2,a3合并后的a5:{a5}")
print()
#统计集合元素数量:len
x=len(a5)
print(f"a5里有{x}个元素")#统计的是去重后的
print()

###########集合的遍历,不能使用while因为不能索引,但是可以for循环
for i in a5:
    print(f"a5里有:{i}")



print()
#清空法:x1.clear()
a1.clear()
print(f"清空后的a1:{a1}")

"""
字典
[字]:[含义]
Key:Value
使用{key元素:value,}
不允许重复
但是可以修改和新增
"""
b1={
    "清融":"中单",
    "星痕":"上单",
    "无畏":"打野"
}#通过A找到对应的B
print(f"字典b1的内容:{b1}\n字典类型是:{type(b1)}")
#######使用:
print(f"现在输出无畏的位置:{b1["无畏"]}")##这样就只输出无畏对应的value了
print()

#####字典的嵌套(只能嵌套value)
b2={
    "清融":{
        "位置":"中单",
        "生存":90,
        "经济":60,
        "kda":95
    },
    "无畏":{
        "位置":"打野",
        "生存":70,
        "经济":90,
        "kda":85
    }
}
print(f"清融生存情况:{b2["清融"]["生存"]}")
print()

###############字典的修改操作
b2["清融"]["经济"]=70
print(f"修改后清融的经济:{b2["清融"]["经济"]}")
print()
######################历遍字典
#获取全部key
b4=b2.keys()
print(f"字典里面有:{b4}")
m=1
for j in b4:
    print(f"字典里的第{m}个key是:{j}")
    b2[j]["生存"]+=10
    print(f"第{m}个key对应的value,生存能力上涨后的是:{b2[j]}")
    m+=1

print()
############字典长度len
b5=len(b2["清融"])#这样就是清融下的嵌套字典
print(f"字典里有{b5}个元素")



print("\n\n\n")
##########字典的取出pop,取出后字典里就没有了
b3=b2.pop("无畏")
print(f"字典里被移除了:{b3},\n原来字典里还有:{b2}")
#我们可以看到,拿出来的只是无畏的value,而不包括无畏这个key
print()










































